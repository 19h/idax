/// \file name_bind.cpp
/// \brief NAN bindings for ida::name namespace.
///
/// Exposes naming, demangling, name inventory queries, and name property
/// operations to JavaScript.

#include "helpers.hpp"
#include <ida/name.hpp>

namespace idax_node {
namespace {

// ── Enum helpers ────────────────────────────────────────────────────────

/// Parse DemangleForm from a JS string. Defaults to Short on unrecognized.
ida::name::DemangleForm ParseDemangleForm(const std::string& s) {
    if (s == "long") return ida::name::DemangleForm::Long;
    if (s == "full") return ida::name::DemangleForm::Full;
    return ida::name::DemangleForm::Short;
}

/// Convert a name::Entry to a JS object.
v8::Local<v8::Object> EntryToObject(const ida::name::Entry& entry) {
    return ObjectBuilder()
        .setAddr("address", entry.address)
        .setStr("name", entry.name)
        .setBool("userDefined", entry.user_defined)
        .setBool("autoGenerated", entry.auto_generated)
        .build();
}

/// Convert a vector of name entries to a JS array.
v8::Local<v8::Array> EntryVectorToArray(const std::vector<ida::name::Entry>& entries) {
    auto arr = Nan::New<v8::Array>(static_cast<int>(entries.size()));
    for (std::size_t i = 0; i < entries.size(); ++i) {
        Nan::Set(arr, static_cast<uint32_t>(i), EntryToObject(entries[i]));
    }
    return arr;
}

// ── NAN method implementations ──────────────────────────────────────────

// set(address, name) -> void
NAN_METHOD(Set) {
    ida::Address addr;
    if (!GetAddressArg(info, 0, addr)) return;

    std::string name;
    if (!GetStringArg(info, 1, name)) return;

    IDAX_CHECK_STATUS(ida::name::set(addr, name));
}

// forceSet(address, name) -> void
NAN_METHOD(ForceSet) {
    ida::Address addr;
    if (!GetAddressArg(info, 0, addr)) return;

    std::string name;
    if (!GetStringArg(info, 1, name)) return;

    IDAX_CHECK_STATUS(ida::name::force_set(addr, name));
}

// remove(address) -> void
NAN_METHOD(Remove) {
    ida::Address addr;
    if (!GetAddressArg(info, 0, addr)) return;

    IDAX_CHECK_STATUS(ida::name::remove(addr));
}

// get(address) -> string
NAN_METHOD(Get) {
    ida::Address addr;
    if (!GetAddressArg(info, 0, addr)) return;

    IDAX_UNWRAP(auto name, ida::name::get(addr));
    info.GetReturnValue().Set(FromString(name));
}

// demangled(address, form?) -> string
// form: "short" | "long" | "full" (default "short")
NAN_METHOD(Demangled) {
    ida::Address addr;
    if (!GetAddressArg(info, 0, addr)) return;

    auto formStr = GetOptionalString(info, 1, "short");
    auto form = ParseDemangleForm(formStr);

    IDAX_UNWRAP(auto name, ida::name::demangled(addr, form));
    info.GetReturnValue().Set(FromString(name));
}

// resolve(name, context?) -> BigInt (address)
NAN_METHOD(Resolve) {
    std::string name;
    if (!GetStringArg(info, 0, name)) return;

    ida::Address context = GetOptionalAddress(info, 1, ida::BadAddress);

    IDAX_UNWRAP(auto addr, ida::name::resolve(name, context));
    info.GetReturnValue().Set(FromAddress(addr));
}

// all(options?) -> array of entry objects
// options: { start?, end?, includeUserDefined?, includeAutoGenerated? }
NAN_METHOD(All) {
    ida::name::ListOptions opts;

    if (info.Length() > 0 && info[0]->IsObject()) {
        auto optObj = info[0].As<v8::Object>();
        auto context = v8::Isolate::GetCurrent()->GetCurrentContext();

        // start
        auto startKey = FromString("start");
        auto startVal = Nan::Get(optObj, startKey).ToLocalChecked();
        if (!startVal->IsUndefined() && !startVal->IsNull()) {
            ToAddress(startVal, opts.start);
        }

        // end
        auto endKey = FromString("end");
        auto endVal = Nan::Get(optObj, endKey).ToLocalChecked();
        if (!endVal->IsUndefined() && !endVal->IsNull()) {
            ToAddress(endVal, opts.end);
        }

        // includeUserDefined
        auto iudKey = FromString("includeUserDefined");
        auto iudVal = Nan::Get(optObj, iudKey).ToLocalChecked();
        if (iudVal->IsBoolean()) {
            opts.include_user_defined = Nan::To<bool>(iudVal).FromJust();
        }

        // includeAutoGenerated
        auto iagKey = FromString("includeAutoGenerated");
        auto iagVal = Nan::Get(optObj, iagKey).ToLocalChecked();
        if (iagVal->IsBoolean()) {
            opts.include_auto_generated = Nan::To<bool>(iagVal).FromJust();
        }
    }

    IDAX_UNWRAP(auto entries, ida::name::all(opts));
    info.GetReturnValue().Set(EntryVectorToArray(entries));
}

// allUserDefined(start?, end?) -> array of entry objects
NAN_METHOD(AllUserDefined) {
    ida::Address start = GetOptionalAddress(info, 0, ida::BadAddress);
    ida::Address end   = GetOptionalAddress(info, 1, ida::BadAddress);

    IDAX_UNWRAP(auto entries, ida::name::all_user_defined(start, end));
    info.GetReturnValue().Set(EntryVectorToArray(entries));
}

// ── Name property queries ───────────────────────────────────────────────

// isPublic(address) -> bool
NAN_METHOD(IsPublic) {
    ida::Address addr;
    if (!GetAddressArg(info, 0, addr)) return;
    info.GetReturnValue().Set(Nan::New(ida::name::is_public(addr)));
}

// isWeak(address) -> bool
NAN_METHOD(IsWeak) {
    ida::Address addr;
    if (!GetAddressArg(info, 0, addr)) return;
    info.GetReturnValue().Set(Nan::New(ida::name::is_weak(addr)));
}

// isUserDefined(address) -> bool
NAN_METHOD(IsUserDefined) {
    ida::Address addr;
    if (!GetAddressArg(info, 0, addr)) return;
    info.GetReturnValue().Set(Nan::New(ida::name::is_user_defined(addr)));
}

// isAutoGenerated(address) -> bool
NAN_METHOD(IsAutoGenerated) {
    ida::Address addr;
    if (!GetAddressArg(info, 0, addr)) return;
    info.GetReturnValue().Set(Nan::New(ida::name::is_auto_generated(addr)));
}

// isValidIdentifier(text) -> bool
NAN_METHOD(IsValidIdentifier) {
    std::string text;
    if (!GetStringArg(info, 0, text)) return;

    IDAX_UNWRAP(auto valid, ida::name::is_valid_identifier(text));
    info.GetReturnValue().Set(Nan::New(valid));
}

// sanitizeIdentifier(text) -> string
NAN_METHOD(SanitizeIdentifier) {
    std::string text;
    if (!GetStringArg(info, 0, text)) return;

    IDAX_UNWRAP(auto sanitized, ida::name::sanitize_identifier(text));
    info.GetReturnValue().Set(FromString(sanitized));
}

// setPublic(address, value?) -> void (default true)
NAN_METHOD(SetPublic) {
    ida::Address addr;
    if (!GetAddressArg(info, 0, addr)) return;
    bool value = GetOptionalBool(info, 1, true);
    IDAX_CHECK_STATUS(ida::name::set_public(addr, value));
}

// setWeak(address, value?) -> void (default true)
NAN_METHOD(SetWeak) {
    ida::Address addr;
    if (!GetAddressArg(info, 0, addr)) return;
    bool value = GetOptionalBool(info, 1, true);
    IDAX_CHECK_STATUS(ida::name::set_weak(addr, value));
}

} // anonymous namespace

// ── Module registration ─────────────────────────────────────────────────

void InitName(v8::Local<v8::Object> target) {
    auto ns = CreateNamespace(target, "name");

    // Core naming
    SetMethod(ns, "set",      Set);
    SetMethod(ns, "forceSet", ForceSet);
    SetMethod(ns, "remove",   Remove);
    SetMethod(ns, "get",      Get);
    SetMethod(ns, "demangled", Demangled);
    SetMethod(ns, "resolve",  Resolve);

    // Name inventory
    SetMethod(ns, "all",            All);
    SetMethod(ns, "allUserDefined", AllUserDefined);

    // Name property queries
    SetMethod(ns, "isPublic",       IsPublic);
    SetMethod(ns, "isWeak",         IsWeak);
    SetMethod(ns, "isUserDefined",  IsUserDefined);
    SetMethod(ns, "isAutoGenerated", IsAutoGenerated);

    // Validation / sanitization
    SetMethod(ns, "isValidIdentifier",  IsValidIdentifier);
    SetMethod(ns, "sanitizeIdentifier", SanitizeIdentifier);

    // Property setters
    SetMethod(ns, "setPublic", SetPublic);
    SetMethod(ns, "setWeak",   SetWeak);
}

} // namespace idax_node
